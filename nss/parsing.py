# Reference: https://blog.usejournal.com/writing-your-own-programming-language-and-compiler-with-python-a468970ae6dffrom rply import LexerGenerator, ParserGeneratorfrom nss import scriptfrom nss.operators import OPERATORS, LEVELS, OpType, ArgTypetypes = [    'void', 'int', 'string', 'float', 'object', 'location', 'talent', 'vector', 'itemproperty',    'effect', 'action', "event", "INT", "OBJECT_ID"]types = [x + "\s+" for x in types]controls = [    'if', 'elif', 'else', 'while', 'do', 'case', 'switch', "break", "for", "default", "struct "]class Lexer:    rules = [        # ("LINE_COMMENT", r'//.*[\n]?'),        # ("MULTILINE_COMMENT", r'\/\*(.|\n|\r\n)*?\*\/'),        ("VECTOR", r'\[\d+.\d+,\d+.\d+,\d+.\d+\]'),        ("HEXADECIMAL", r'0x[a|b|c|d|e|f|A|B|C|D|E|F|\d]+'),        ('FLOAT', r'\d+\.\d+f?'),        ('INTEGER', r'\d+'),  # http://regexlib.com/Search.aspx?k=integer&AspxAutoDetectCookieSupport=1        # ('BOOLEAN', r'TRUE|FALSE'),        # ("STRUCT_VAR", "[a-zA-Z][a-zA-Z0-9]+\.[a-zA-Z][a-zA-Z0-9]+"),        ('STRING', r'".*?"'),        ('OPEN_BRACKET', r'\('),        ('CLOSE_BRACKET', r'\)'),        ('OPEN_CURLY', r'{'),        ('CLOSE_CURLY', r'}'),        ("COMMA", r','),        ("COLON", ":"),        ("FULLSTOP", r"\."),        ('SEMICOLON', r';'),        ("ASSIGNMENT_OPERATOR", "/=|\*=|\+=|-="),        # ("MINUS", "-")    ]    rules_after_ops = [        ('RETURN', r'return'),        ('VARIABLE', r'[a-zA-Z_][a-zA-Z0-9_\.]*'),        ('COMMENT_LINE', r'//.*?\n'),        ('COMMENT', r'/\*.*?\*/'),        ('INCLUDE', r'#include'),        ("DEFINE", r'#define'),        ('ASSIGNMENT', r'=')    ]    # We may or may not want to know about new lines    # Reference: https://stackoverflow.com/questions/3469080/match-whitespace-but-not-newlines    ignore = [        "\s+",        r'//.*[\n]?',  # Ignore comments (i.e. the contents of any line from the first non-escaped hashtag onwards        r'\/\*(.|\n|\r\n)*?\*\/'  # Ignore multiline comments    ]    def __init__(self):        lexer_generator = LexerGenerator()        self.add_tokens(lexer_generator)        self.lexer = lexer_generator.build()    def get_all_rules(self):        rules = []        for operator_name, operator_regex in self.rules:            rules.append((operator_name, operator_regex))        rules.append(("TYPE", "|".join(types)))        ops = [(k, OPERATORS[k]) for k in OPERATORS]        ops.sort(key=lambda x: x[1].lex_priority)        for operator_name, operator_definition in ops:            rules.append((operator_name.upper().strip(), operator_definition.regex))        for c in controls:            rules.append((c.upper().strip(), c))        for operator_name, operator_regex in self.rules_after_ops:            rules.append((operator_name, operator_regex))        # rules.append(("ASSIGNMENT_OPERATOR", "|".join(op[1] for op in assignment_operations)))        # for op_name, op_syntax in operations:        #     rules.append((op_name, op_syntax))        return rules    def add_tokens(self, lexer):        # Add regex for all operators        # for t in types:        #     lexer.add(t.upper(), t)        for name, regex in self.get_all_rules():            lexer.add(name, regex)        # Add all ignore regex        for ignore_regex in self.ignore:            lexer.ignore(ignore_regex)    def lex(self, *args, **kwargs):        return self.lexer.lex(*args, **kwargs)class Parser():    def __init__(self, lexer):        self.pg = ParserGenerator(            # A list of all token names accepted by the core.            list([x[0] for x in lexer.get_all_rules()]),            precedence=[                           ('left', ["constant"]),                           ('left', ["non_constant"])                       ] + [('left', [op.upper() for op in LEVELS[level]]) for level in                            sorted(LEVELS.keys(), reverse=True)]        )        # @self.pg.production('this_script : declarations')        # def this_script_declarations(p):        #     script_declarations = p[0]        #     return script.Program(None, script_declarations, None)        @self.pg.production('this_script : script_body')        def this_script(p):            return script.Program(p[0])        @self.pg.production('script_body : script_component script_body')        @self.pg.production('script_body : script_component')        def script_body(p):            component = p[0]            if len(p) == 1:                return [component]            else:                return [component] + p[1]        @self.pg.production('script_component : function')        @self.pg.production('script_component : defined_constant')        @self.pg.production('script_component : struct')        def script_component(p):            return p[0]        @self.pg.production('struct : STRUCT VARIABLE OPEN_CURLY struct_body CLOSE_CURLY SEMICOLON')        def struct(p):            return script.Struct(p[1], p[3])        @self.pg.production('struct_body : TYPE VARIABLE SEMICOLON struct_body')        @self.pg.production('struct_body : TYPE VARIABLE SEMICOLON')        def struct_body(p):            var = script.CreateVariable(p[0], p[1], None, True)            if len(p) == 3:                return [var]            else:                return [var] + p[3]        @self.pg.production('includes : ')        @self.pg.production('body : ')        def blank(p):            return []        @self.pg.production('script_component : INCLUDE STRING')        def include(p):            if len(p) == 2:                return script.Include(p[1])        @self.pg.production('script_component : DEFINE VARIABLE INTEGER')        @self.pg.production('script_component : DEFINE VARIABLE VARIABLE')        @self.pg.production('script_component : DEFINE VARIABLE TYPE')        def define(p):            return script.Define(p[1], p[2])        @self.pg.production("defined_constant : TYPE VARIABLE SEMICOLON")        def declaration_no_value(p):            var_type = p[0]            var_name = p[1]            return script.DefinedConstant(var_type, var_name, None)        @self.pg.production("defined_constant : TYPE VARIABLE ASSIGNMENT expression SEMICOLON")        @self.pg.production("defined_constant : TYPE VARIABLE ASSIGNMENT_OPERATOR expression SEMICOLON")        def declaration(p):            var_type = p[0]            var_name = p[1]            var_value = p[3]            return script.DefinedConstant(var_type, var_name, var_value)        @self.pg.production('defined_constant : STRUCT VARIABLE VARIABLE SEMICOLON')        def declare_struct_variable(p):            struct_type = p[1]            struct_name = p[2]            return script.DeclareStruct(struct_type, struct_name)        @self.pg.production('function : TYPE VARIABLE OPEN_BRACKET defined_arguments CLOSE_BRACKET SEMICOLON')        def function_declaration(p):            f_type = p[0]            f_name = p[1]            f_args = p[3]            return script.FunctionDeclaration(f_type, f_name, f_args);        @self.pg.production('function : TYPE VARIABLE OPEN_BRACKET CLOSE_BRACKET SEMICOLON')        def function_declaration_no_args(p):            f_type = p[0]            f_name = p[1]            return script.FunctionDeclaration(f_type, f_name, []);        @self.pg.production(            'function : TYPE VARIABLE OPEN_BRACKET defined_arguments CLOSE_BRACKET OPEN_CURLY body CLOSE_CURLY')        def function(p):            f_type = p[0]            f_name = p[1]            f_args = p[3]            f_body = p[6]            return script.FunctionDefinition(f_type, f_name, f_args, f_body)        @self.pg.production(            'function : TYPE VARIABLE OPEN_BRACKET CLOSE_BRACKET OPEN_CURLY body CLOSE_CURLY')        def function_no_args(p):            f_type = p[0]            f_name = p[1]            f_body = p[5]            return script.FunctionDefinition(f_type, f_name, [], f_body)        @self.pg.production('defined_arguments : TYPE VARIABLE COMMA defined_arguments')        @self.pg.production('defined_arguments : TYPE VARIABLE')        def defined_arguments(p):            arg_type = p[0]            arg_name = p[1]            arg = script.DefinedArgument(arg_type, arg_name, None)            if len(p) == 2:                return [arg]            else:                return [arg] + p[3]        @self.pg.production('defined_arguments : TYPE VARIABLE ASSIGNMENT constant COMMA defined_arguments')        @self.pg.production('defined_arguments : TYPE VARIABLE ASSIGNMENT constant')        @self.pg.production('defined_arguments : TYPE VARIABLE ASSIGNMENT VARIABLE COMMA defined_arguments')        @self.pg.production('defined_arguments : TYPE VARIABLE ASSIGNMENT VARIABLE')        def defined_arguments_with_default(p):            arg_type = p[0]            arg_name = p[1]            arg_default = p[3]            arg = script.DefinedArgument(arg_type, arg_name, p[3])            if len(p) == 4:                return [arg]            else:                return [arg] + p[5]        @self.pg.production('body : segment')        @self.pg.production('body : segment body')        def body(p):            if len(p) == 1:                return [p[0]]            else:                return [p[0]] + p[1]        @self.pg.production('segment : line')        @self.pg.production('segment : control')        def segment(p):            return p[0]        @self.pg.production('line : RETURN expression SEMICOLON')        def return_line(p):            exp = p[1]            return script.Return(exp)        @self.pg.production('line : RETURN SEMICOLON')        def return_void(p):            return script.Return(None)        @self.pg.production('control : if')        @self.pg.production('control : for')        @self.pg.production('control : while')        @self.pg.production('control : do')        @self.pg.production('control : switch')        def control(p):            return p[0]        @self.pg.production('if : IF OPEN_BRACKET expression CLOSE_BRACKET OPEN_CURLY body CLOSE_CURLY')        @self.pg.production('if : IF OPEN_BRACKET expression CLOSE_BRACKET OPEN_CURLY body CLOSE_CURLY ELSE if')        def if_statement(p):            if_exp = p[2]            if_body = p[5]            if len(p) == 7:                return script.If(if_exp, if_body, None)            else:                if_else = p[8]                return script.If(if_exp, if_body, if_else)        @self.pg.production('if : OPEN_CURLY body CLOSE_CURLY')        def else_statement(p):            else_body = p[1]            return script.Body(else_body)        @self.pg.production('if : IF OPEN_BRACKET expression CLOSE_BRACKET line')        @self.pg.production('if : IF OPEN_BRACKET expression CLOSE_BRACKET line ELSE if')        def if_statement_one_line(p):            if_exp = p[2]            if_body = p[4]            if len(p) == 5:                return script.If(if_exp, if_body, None)            else:                if_else = p[6]                return script.If(if_exp, if_body, if_else)        @self.pg.production('if : line')        def else_statement_one_line(p):            else_body = p[0]            return script.Body(else_body)        @self.pg.production('while : WHILE OPEN_BRACKET expression CLOSE_BRACKET OPEN_CURLY body CLOSE_CURLY')        def while_loop(p):            while_exp = p[2]            while_body = p[5]            return script.While(while_exp, while_body)        @self.pg.production('do : DO OPEN_CURLY body CLOSE_CURLY WHILE OPEN_BRACKET expression CLOSE_BRACKET SEMICOLON')        def do_loop(p):            do_body = p[2]            do_exp = p[6]            return script.Do(do_exp, do_body)        @self.pg.production('for : FOR for_def OPEN_CURLY body CLOSE_CURLY')        def for_loop(p):            for_def = p[1]            body = p[3]            return script.For(for_def, body)        @self.pg.production('for_def : OPEN_BRACKET assign SEMICOLON expression SEMICOLON assign CLOSE_BRACKET')        @self.pg.production('for_def : OPEN_BRACKET assign SEMICOLON expression SEMICOLON expression CLOSE_BRACKET')        @self.pg.production('for_def : OPEN_BRACKET expression SEMICOLON expression SEMICOLON expression CLOSE_BRACKET')        def for_def(p):            init = p[1]            cond = p[3]            after = p[5]            return script.ForDef(init, cond, after)        @self.pg.production('switch : SWITCH OPEN_BRACKET expression CLOSE_BRACKET OPEN_CURLY switch_body CLOSE_CURLY')        def switch_statement(p):            exp = p[2]            switch_body = p[5]            return script.Switch(exp, switch_body)        @self.pg.production('case_start : CASE expression COLON case_start')        @self.pg.production('case_start : CASE expression COLON')        @self.pg.production('case_start : DEFAULT COLON')        def case_start(p):            if len(p) == 2:                return []            exp = p[1]            if len(p) == 3:                return [exp]            else:                return [exp] + p[3]        @self.pg.production('switch_body : case_start body BREAK SEMICOLON')        @self.pg.production('switch_body : case_start body BREAK SEMICOLON switch_body')        @self.pg.production('switch_body : case_start body')        @self.pg.production('switch_body : case_start body switch_body')        def switch_case(p):            exp = p[0]            case_body = p[1]            if len(p) == 2:                return [script.SwitchCase(exp, case_body, False)]            elif len(p) == 3:                return [script.SwitchCase(exp, case_body, False)] + p[2]            elif len(p) == 4:                return [script.SwitchCase(exp, case_body, True)]            else:                return [script.SwitchCase(exp, case_body, True)] + p[4]        @self.pg.production('switch_body : ')        def blank_switch(p):            return []        @self.pg.production('line : TYPE VARIABLE SEMICOLON')        def create_var(p):            var_type = p[0]            var_name = p[1]            return script.CreateVariable(var_type, var_name, None)        @self.pg.production('line : TYPE VARIABLE more_variables SEMICOLON')        def create_vars(p):            var_type = p[0]            var_name = p[1]            other_vars = p[2]            return script.CreateMultipleVariables(var_type, [var_name] + other_vars)        @self.pg.production('more_variables : VARIABLE more_variables')        @self.pg.production('more_variables : VARIABLE')        def more_variables(p):            var_name = p[0]            if len(p) == 1:                return [var_name]            else:                return [var_name] + p[1]        @self.pg.production('line : define')        def create_single(p):            return p[0]        @self.pg.production('define : TYPE assign SEMICOLON')        def define_variable(p):            var_type = p[0]            var_assignment = p[1]            return script.CreateVariable(var_type, var_assignment.var_name, var_assignment.expression)        @self.pg.production('line : TYPE VARIABLE COMMA trailing_assigns SEMICOLON')        def create_multiple(p):            var_type = p[0]            var_assignment = p[1]            return script.CreateMultipleVariables(                var_type=var_type,                var_assignments=[                    var_assignment,                    *p[3]                ]            )        # TODO: Make sure it's reasonable to ignore random breaks        @self.pg.production('line : BREAK SEMICOLON')        @self.pg.production('line : SEMICOLON')        def null_op(p):            return script.NullOp()        @self.pg.production('trailing_assigns : VARIABLE')        @self.pg.production('trailing_assigns : VARIABLE COMMA trailing_assigns')        def trailing_assign(p):            var_name = p[0]            if len(p) == 1:                return [var_name]            else:                return [var_name] + p[2]        @self.pg.production('line : assign SEMICOLON')        def line_assign(p):            return p[0]        # @self.pg.production('assign : STRUCT_VAR ASSIGNMENT expression')        # @self.pg.production('assign : STRUCT_VAR ASSIGNMENT_OPERATOR expression')        @self.pg.production('assign : VARIABLE ASSIGNMENT expression')        @self.pg.production('assign : VARIABLE ASSIGNMENT_OPERATOR expression')        def assign(p):            var_name = p[0]            operator = p[1]            exp = p[2]            return script.Assignment(var_name, operator, exp)        @self.pg.production('line : expression SEMICOLON')        def expression(p):            return p[0]        @self.pg.production('non_constant : VARIABLE OPEN_BRACKET calling_arguments CLOSE_BRACKET')        def function_call(p):            fn_name = p[0]            fn_args = p[2]            return script.FunctionCall(fn_name, fn_args)        @self.pg.production('calling_arguments : calling_argument COMMA calling_arguments')        @self.pg.production('calling_arguments : calling_argument')        def calling_arguments(p):            arg = p[0]            if len(p) == 1:                return [arg]            else:                return [arg] + p[2]        @self.pg.production("calling_argument : expression")        def calling_argument(p):            exp = p[0]            return script.CallingArgument(exp)        @self.pg.production("calling_argument : ")        def blank_calling_argument(p):            return []        @self.pg.production("expression : constant")        def constant(p):            value = p[0]            return value        @self.pg.production("expression : non_constant")        def non_constant(p):            value = p[0]            return value        @self.pg.production('constant : MINUS INTEGER')        @self.pg.production('constant : INTEGER')        def integer_fn(p):            if len(p) == 1:                value = p[0]            else:                value = p[1]            return script.Integer(value, len(p) == 2)        @self.pg.production('constant : STRING')        def string_fn(p):            value = p[0]            return script.String(value)        # @self.pg.production('constant : BOOLEAN')        # def boolean(p):        #     value = p[0]        #     return script.Boolean(value)        @self.pg.production('constant : MINUS FLOAT')        @self.pg.production('constant : FLOAT')        def float_fn(p):            if len(p) == 1:                value = p[0]            else:                value = p[1]            return script.Float(value, len(p) == 2)        @self.pg.production('constant : HEXADECIMAL')        def hexadecimal(p):            value = p[0]            return script.Hexadecimal(value)        @self.pg.production('constant : VECTOR')        def vector(p):            value = p[0]            return script.Vector(value)        # @self.pg.production('expression : STRUCT_VAR')        # def struct_access(p):        #     struct_name, struct_var = p[0].getstr().split(".")        #        #     return script.StructAccess(struct_name, struct_var)        for operator in OPERATORS:            self.create_operator(operator)        @self.pg.production('non_constant : MINUS non_constant')        def unary_operation_prefix(p):            exp = p[1]            return script.Minus(exp)        @self.pg.production('non_constant : VARIABLE')        def variable(p):            var_name = p[0]            return script.UsedVariable(var_name)        @self.pg.production('non_constant : OPEN_BRACKET expression CLOSE_BRACKET')        def brackets(p):            exp = p[1]            return exp        # TODO: Make sure this is reasonable when I've not been coding for 14 hours straight...        @self.pg.production('non_constant : assign')        def assign_exp(p):            exp = p[0]            return exp        @self.pg.error        def error_handle(token):            raise Exception("Failed on {}".format(token))    def create_operator(self, op_name):        op_def = OPERATORS[op_name]        if op_def.optype is OpType.Binary:            def bin_fn(p):                exp1 = p[0]                operator = p[1]                exp2 = p[2]                return script.BinaryOperation(op_def, exp1, operator, exp2)            self.pg.production('non_constant : expression {} expression'.format(op_name.upper()))(bin_fn)        if op_def.optype in (OpType.Unary, OpType.UnaryPrefix):            def unary_prefix_fn(p):                exp = p[1]                operator = p[0]                return script.UnaryPrefixOperation(op_def, operator, exp)            self.pg.production('non_constant : {} expression'.format(op_name.upper()))(unary_prefix_fn)        if op_def.optype in (OpType.Unary, OpType.UnaryPostfix):            def unary_postfix_fn(p):                exp = p[0]                operator = p[1]                return script.UnaryPostfixOperation(op_def, exp, operator)            self.pg.production('non_constant : expression {}'.format(op_name.upper()))(unary_postfix_fn)        if op_def.optype is OpType.SelfModifying:            def self_modifying_prefix_fn(p):                exp = p[1]                operator = p[0]                return script.SelfModifyingPrefixOperation(op_def, operator, exp)            self.pg.production('non_constant : {} expression'.format(op_name.upper()))(self_modifying_prefix_fn)            def self_modifying_postfix_fn(p):                exp = p[0]                operator = p[1]                return script.SelfModifyingPostfixOperation(op_def, exp, operator)            self.pg.production('non_constant : expression {}'.format(op_name.upper()))(self_modifying_postfix_fn)    def get_parser(self):        return self.pg.build()